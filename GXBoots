library(Seurat)
library(dplyr)
library(readr)
library(e1071)
library(caret)
library(rpart) 
library(ggplot2)
library(rpart.plot)
library(iml)
library(data.table)
library(ggpubr)
library(clusterProfiler)
library(org.Hs.eg.db)
library(enrichplot)
library(httr)
library(jsonlite)
library(readxl)
library(janitor)
library(reshape2)
library(randomForest)
library(reshape2)
library(xgboost)
library(Matrix)
library(openxlsx)
library(DALEX)
library(MLmetrics)
# ===============================================================
library(Seurat)             # For single-cell RNA-seq analysis
library(dplyr)              # Data manipulation
library(readr)              # For reading CSV, TSV, etc.
library(e1071)              # For SVM (Support Vector Machines)
library(caret)              # For machine learning workflows
library(rpart)              # For decision trees
library(ggplot2)            # For plotting
library(rpart.plot)         # For plotting decision trees
library(iml)                # For interpretable machine learning
library(data.table)         # For faster data manipulation
library(ggpubr)             # For enhanced ggplot2
library(clusterProfiler)    # For Gene Ontology and KEGG analysis
library(org.Hs.eg.db)       # For human gene annotation
library(enrichplot)         # For enrichment plot visualization
library(httr)               # For HTTP requests (e.g., API calls)
library(jsonlite)           # For handling JSON data
library(readxl)             # For reading Excel files
library(janitor)            # For cleaning data
library(reshape2)           # For reshaping data
library(randomForest)       # For random forest classification
library(xgboost)            # For gradient boosting machine learning
library(Matrix)             # For sparse matrix operations
library(openxlsx)           # For reading/writing Excel files
library(DALEX)              # For explainable AI
library(MLmetrics)          # For machine learning metrics

# =====================================================================

# Read the CSV file with biomarker information
file_path <- "D:\\Thesis\\Proposal\\Analysis\\TOP-BIOMARKERS\\Results\\Top200_Biomarkers_WeightedScore.csv"
data <- read.csv(file_path, header = TRUE)  # Load biomarker data
d <- data$gene  # Extract the 'gene' column containing gene names

# Set the directory path where the sample files are stored
data_dir <- "D:/Thesis/Proposal/Thesis_Data/GSE169246/files"

# Define the names of the samples to be used
names <- c("Pre_P001_b", "Pre_P002_b", "Pre_P002_t", "Pre_P004_b", "Pre_P004_t", "Pre_P005_b", 
           "Pre_P005_t", "Pre_P007_b", "Pre_P007_t", "Pre_P008_b", "Pre_P010_b", "Pre_P011_b", 
           "Pre_P013_b", "Pre_P013_t", "Pre_P016_b", "Pre_P016_t")

# Get all directories in the data folder, only keeping the directories that match the sample names
sample_dirs <- list.dirs(data_dir, recursive = TRUE, full.names = TRUE)
sample_dirs <- sample_dirs[basename(sample_dirs) %in% names]

# Initialize a list to store Seurat objects for each sample
seurat_list <- list()
for (dir in sample_dirs) {
  sample_name <- basename(dir)
  counts <- Read10X(data.dir = dir)  # Read in the single-cell RNA-seq data
  colnames(counts) <- paste(sample_name, colnames(counts), sep = "-")  # Modify column names to include sample name
  seurat_obj <- CreateSeuratObject(counts = counts, project = sample_name)  # Create Seurat object for each sample
  seurat_list[[sample_name]] <- seurat_obj@assays$RNA@counts  # Store RNA counts matrix in the list
}

# Combine all counts data from different samples into one large matrix
combined_counts <- do.call(cbind, seurat_list)

# Filter the combined counts matrix to include only the genes of interest (based on the biomarker list)
filtered_counts <- combined_counts[rownames(combined_counts) %in% d, ]

# Save the filtered counts matrix to an RDS file
saveRDS(filtered_counts, "D:/Thesis/Proposal/Analysis/Machine Learning/Results/filtered_counts_matrix.rds")
filtered_counts <- readRDS("D:/Thesis/Proposal/Analysis/Machine Learning/Results/filtered_counts_matrix.rds")

# Create a data frame for cell labels (progressive or non-progressive)
cell_names <- colnames(combined_counts)
sample_ids <- sapply(strsplit(cell_names, "-"), `[`, 1)
unique_samples <- unique(sample_ids)
cell_labels <- data.frame(Cell = character(), Label = character(), stringsAsFactors = FALSE)

# Loop through each unique sample to assign a label (progressive or non-progressive)
valid_labels <- c("progressive", "non-progressive")
for (sample in unique_samples) {
  repeat {
    label <- readline(prompt = paste0("Enter label for sample '", sample, "' (progressive / non-progressive): "))
    label <- trimws(tolower(label))  # Clean up the input and convert to lowercase
    if (label %in% valid_labels) break
    cat("â›” Invalid input. Please enter only 'progressive' or 'non-progressive'.\n")
  }
  cells <- cell_names[sample_ids == sample]
  sample_df <- data.frame(Cell = cells, Label = label, stringsAsFactors = FALSE)
  cell_labels <- rbind(cell_labels, sample_df)  # Add the label to the cell_labels data frame
}

# Save the cell labels to an RDS file
saveRDS(cell_labels, "D:/Thesis/Proposal/Analysis/Machine Learning/Results/cell_labels.rds")
cell_labels <- readRDS("D:/Thesis/Proposal/Analysis/Machine Learning/Results/cell_labels.rds")

# Write cell labels to CSV for reference
write.csv(cell_labels, "D:\\Thesis\\Proposal\\Analysis\\Machine Learning\\Results\\cell_labels.csv", row.names = FALSE)
fwrite(cell_labels, file = "D:/Thesis/Proposal/Analysis/Machine Learning/Results/cell_labels_fast.csv", row.names = FALSE)

# =========================================================================== XGBoost

# Reload the filtered counts and cell labels data
filtered_counts <- readRDS("D:/Thesis/Proposal/Analysis/Machine Learning/Results/filtered_counts_matrix.rds")
cell_labels <- readRDS("D:/Thesis/Proposal/Analysis/Machine Learning/Results/cell_labels.rds")

# Step 2: Ensure cell names match between filtered counts and cell labels
common_cells <- intersect(colnames(filtered_counts), cell_labels$Cell)
filtered_counts <- filtered_counts[, common_cells]
cell_labels <- cell_labels[cell_labels$Cell %in% common_cells, ]

# Step 3: Prepare the data frame for machine learning
df <- as.data.frame(t(as.matrix(filtered_counts)))  # Transpose so that cells are rows
df$Cell <- rownames(df)  # Add the cell names as a column
df <- merge(df, cell_labels, by = "Cell")  # Merge with cell labels to add the labels (progressive/non-progressive)

# Step 4: Prepare data for XGBoost
X_all <- df[, !(names(df) %in% c("Cell", "Label"))]  # Exclude Cell and Label columns
y_all <- gsub("-", "_", df$Label)  # Replace hyphens with underscores in the labels

# If preprocessing is needed (standardization)
preProc_all <- preProcess(X_all, method = c("center", "scale"))  # Standardize the features
X_all_scaled <- predict(preProc_all, X_all)  # Apply preprocessing to the data

# Prepare the final data frame for XGBoost
model_data <- data.frame(X_all_scaled, Label = factor(y_all, levels = c("non_progressive", "progressive")))

# Print the summary of the data
print(dim(model_data))
print(table(model_data$Label))

# Custom summary function for model evaluation
set.seed(123)
train_control <- trainControl(
  method = "cv",
  number = 5,
  classProbs = TRUE,
  summaryFunction = my_summary,  # Custom summary function for model evaluation
  savePredictions = "final",
  verboseIter = TRUE
)

# Hyperparameter grid for XGBoost
xgb_grid <- expand.grid(
  nrounds = 200,
  max_depth = c(3, 5, 7),
  eta = c(0.01, 0.05, 0.1),
  gamma = 0,
  colsample_bytree = 0.8,
  min_child_weight = 1,
  subsample = 0.8
)

# Train the XGBoost model
xgb_model <- train(
  Label ~ .,
  data = model_data,
  method = "xgbTree",
  trControl = train_control,
  tuneGrid = xgb_grid,
  metric = "ROC"  # Optimize for ROC AUC
)

# Save the trained model and results
saveRDS(xgb_model, "D:/Thesis/Proposal/Analysis/Machine Learning/Results/XGBoost/xgboost_cv200f.rds")
write.csv(xgb_model$results, "D:/Thesis/Proposal/Analysis/Machine Learning/Results/XGBoost/xgboost_cv200f.csv", row.names = FALSE)

# Extract and print the best hyperparameters and performance metrics
best_idx <- which.max(xgb_model$results$ROC.ROC)
best_row <- xgb_model$results[best_idx, ]
sink("D:/Thesis/Proposal/Analysis/Machine Learning/Results/XGBoost/xgboost_best_model_summary.txt")

cat("========== XGBoost Best Model Summary ==========\n\n")
cat("Best Hyperparameters:\n")
print(xgb_model$bestTune)
cat(sprintf("\nðŸ“ˆ Best ROC AUC: %.2f%%\n", best_row$ROC.ROC * 100))
cat(sprintf("Sensitivity: %.2f%%\n", best_row$Sens.Sens * 100))
cat(sprintf("Specificity: %.2f%%\n", best_row$Spec.Spec * 100))
cat(sprintf("Accuracy: %.2f%%\n", best_row$Accuracy * 100))

sink()

# Feature importance
importance <- varImp(xgb_model, scale = FALSE)
top_features <- importance$importance
top_features <- top_features[order(-top_features$Overall), , drop = FALSE]
write.csv(top_features, "D:/Thesis/Proposal/Analysis/Machine Learning/Results/XGBoost/xgboost_feature_importance200f.csv")

# Plot the top 20 important features
png("D:/Thesis/Proposal/Analysis/Machine Learning/Results/XGBoost/xgboost_feature_importance_plot200f.png", width = 800, height = 600)
imp_df <- data.frame(Feature = rownames(top_features), Importance = top_features$Overall)
top_n <- head(imp_df, 20)
ggplot(top_n, aes(x = reorder(Feature, Importance), y = Importance)) +
  geom_col(fill = "steelblue") +
  coord_flip() +
  labs(title = "Top 20 Important Features in XGBoost", x = "Feature", y = "Importance") +
  theme_minimal()
dev.off()

# Save subsets of genes based on feature importance
top20 <- head(top_features$Gene, 20)
top50 <- head(top_features$Gene, 50)
top60 <- head(top_features$Gene, 60)
top70 <- head(top_features$Gene, 70)
top80 <- head(top_features$Gene, 80)

save_gene_subset(top20, "D:/Thesis/Proposal/Analysis/Machine Learning/Results/XGBoost/data_top20-200f.csv")
save_gene_subset(top50, "D:/Thesis/Proposal/Analysis/Machine Learning/Results/XGBoost/data_top50-200f.csv")
save_gene_subset(top60, "D:/Thesis/Proposal/Analysis/Machine Learning/Results/XGBoost/data_top60-200f.csv")
save_gene_subset(top70, "D:/Thesis/Proposal/Analysis/Machine Learning/Results/XGBoost/data_top70-200f.csv")
save_gene_subset(top80, "D:/Thesis/Proposal/Analysis/Machine Learning/Results/XGBoost/data_top80-200f.csv")

# Save the initial 200 gene list
d_mapped <- make.names(d)
initial200 <- model_data[, c(intersect(d_mapped, colnames(model_data)), "Label")]
write.csv(initial200, "D:/Thesis/Proposal/Analysis/Machine Learning/Results/XGBoost/data_initial_200.csv", row.names = FALSE)

# ========================================= XGBoost: Connecting Top 20 Genes to Clusters
library(openxlsx)

# Select the top 20 features based on importance
top20_xgb <- head(top_features, 20)
top20_xgb$Feature <- rownames(top20_xgb)

# Write the top 20 features to an Excel file for further analysis
write.xlsx(
  top20_xgb,
  file = "D:/Thesis/Proposal/Analysis/Machine Learning/Results/XGBoost/xgboost_top20_features.xlsx",
  rowNames = FALSE
)

# Prepare the top 20 features dataframe with the 'Importance' column
top20_xgb <- head(top_features, 20)
top20_xgb$Feature <- rownames(top20_xgb)
top20_xgb <- top20_xgb[, c("Feature", "Overall")]
colnames(top20_xgb)[2] <- "Importance"

# Write the top 20 features with their importance to an Excel file
write.xlsx(
  top20_xgb,
  file = "D:/Thesis/Proposal/Analysis/Machine Learning/Results/XGBoost/xgboost_top20_features.xlsx",
  rowNames = FALSE
)

# Read the top 20 features from the Excel file
top20_xgb <- read.xlsx("D:/Thesis/Proposal/Analysis/Machine Learning/Results/XGBoost/xgboost_top20_features.xlsx")
top20_xgb$Gene_lower <- tolower(top20_xgb$Feature)  # Convert gene names to lowercase for matching

# Read the biomarker data and convert gene names to lowercase
biomarker_data <- read.csv("D:/Thesis/Proposal/Analysis/TOP-BIOMARKERS/Results/Top200_Biomarkers_WeightedScore.csv")
biomarker_data$gene_lower <- tolower(biomarker_data$gene)

# Merge the top 20 features with the biomarker data based on gene names
top20_with_cluster_xgb <- merge(
  top20_xgb,
  biomarker_data,
  by.x = "Gene_lower",
  by.y = "gene_lower"
)

# Write the merged top 20 features with cluster information to a CSV file
write.csv(top20_with_cluster_xgb,
          "D:/Thesis/Proposal/Analysis/Machine Learning/Results/XGBoost/xgboost_top20_gene_with_cluster_info_xgb.csv",
          row.names = FALSE)

# Summarize the total importance of genes by cluster
cluster_importance_xgb <- top20_with_cluster_xgb %>%
  dplyr::group_by(cluster_id) %>%
  dplyr::summarise(
    n_genes = dplyr::n(),
    total_importance = sum(Importance),
    mean_importance = mean(Importance),
    .groups = "drop"
  ) %>%
  dplyr::arrange(desc(total_importance))

# Create a bar plot for total importance by cluster
p_xgb <- ggplot(cluster_importance_xgb, aes(x = reorder(cluster_id, total_importance), y = total_importance, fill = cluster_id)) +
  geom_bar(stat = "identity") +
  coord_flip() +
  labs(title = "Total Importance by Cluster (Top 20 Genes - XGBoost)",
       x = "Cluster", y = "Total Importance") +
  theme_minimal(base_size = 14) +
  theme(
    legend.position = "none",
    panel.background = element_rect(fill = "white", color = NA),
    plot.background = element_rect(fill = "white", color = NA)
  )

# Save the plot for total importance by cluster
ggsave("D:/Thesis/Proposal/Analysis/Machine Learning/Results/XGBoost/xgboost_cluster_total_importance_xgb_top20.png",
       plot = p_xgb, width = 10, height = 6, dpi = 300)
print(p_xgb)

# ============================= XGBoost: KEGG & GO Enrichment
top20_xgb <- read.xlsx("D:/Thesis/Proposal/Analysis/Machine Learning/Results/XGBoost/xgboost_top20_features.xlsx")

# Extract gene symbols for KEGG and GO enrichment analysis
gene_symbols <- unique(top20_xgb$Feature)
entrez_ids <- bitr(
  gene_symbols,
  fromType = "SYMBOL",
  toType = "ENTREZID",
  OrgDb = org.Hs.eg.db
)

if (nrow(entrez_ids) == 0) {
  stop("No genes were mapped to Entrez IDs.")
}

# Perform GO enrichment analysis
go_enrich <- enrichGO(
  gene = entrez_ids$ENTREZID,
  OrgDb = org.Hs.eg.db,
  ont = "BP",  # Biological Process
  pvalueCutoff = 0.05,
  readable = TRUE
)

# Perform KEGG enrichment analysis
kegg_enrich <- enrichKEGG(
  gene = entrez_ids$ENTREZID,
  organism = "hsa",  # Human
  pvalueCutoff = 0.05
)

# Make the KEGG results readable
kegg_enrich <- setReadable(kegg_enrich, OrgDb = org.Hs.eg.db, keyType = "ENTREZID")

# Create a KEGG pathway network plot
p_kegg <- cnetplot(
  kegg_enrich,
  showCategory = 10,
  circular = FALSE,
  color.params = list(edge = TRUE)
)

# Save the KEGG plot
ggsave(
  filename = "D:/Thesis/Proposal/Analysis/Machine Learning/Results/XGBoost/xgboost_KEGG_network_plot_top20.png",
  plot = p_kegg,
  width = 12, height = 9, dpi = 300, bg = "white"
)

# Display the GO and KEGG plots
print(p_go)
print(p_kegg)

# ========================================== Identify drug-gene interactions
top20 <- read_csv("D:/Thesis/Proposal/Analysis/Machine Learning/Results/XGBoost/xgboost_top20_gene_with_cluster_info_xgb.csv")
genes <- top20$Gene

# Function to safely extract interactions for a gene
safe_extract_interactions <- function(gene_row) {
  interactions_df <- gene_row$interactions[[1]]
  
  # Check if there are no interactions or invalid data
  if (is.null(interactions_df) || length(interactions_df) == 0 || 
      (is.atomic(interactions_df) && is.na(interactions_df))) {
    message(sprintf("No interactions found for gene: %s", gene_row$name))
    return(NULL)
  }
  
  if (!is.data.frame(interactions_df)) {
    message(sprintf("Interactions is not a data.frame for gene: %s", gene_row$name))
    return(NULL)
  }
  
  # Extract relevant interaction data
  dfs <- lapply(seq_len(nrow(interactions_df)), function(i) {
    inter <- interactions_df[i, ]
    
    tryCatch({
      interactionTypes_text <- if (!is.null(inter$interactionTypes[[1]])) {
        paste(inter$interactionTypes[[1]]$type, collapse = ";")
      } else { NA }
      
      directionality_text <- if (!is.null(inter$interactionTypes[[1]])) {
        paste(inter$interactionTypes[[1]]$directionality, collapse = ";")
      } else { NA }
      
      attributes_text <- if (!is.null(inter$interactionAttributes[[1]])) {
        paste(paste(inter$interactionAttributes[[1]]$name,
                    inter$interactionAttributes[[1]]$value,
                    sep = ":"), collapse = ";")
      } else { NA }
      
      pmids_text <- if (!is.null(inter$publications[[1]])) {
        paste(inter$publications[[1]]$pmid, collapse = ";")
      } else { NA }
      
      sources_text <- if (!is.null(inter$sources[[1]])) {
        paste(inter$sources[[1]]$sourceDbName, collapse = ";")
      } else { NA }
      
      # Create a data frame for the interaction
      data.frame(
        geneName = gene_row$name,
        drugName = inter$drug.name %||% NA,
        conceptId = inter$drug.conceptId %||% NA,
        interactionScore = inter$interactionScore,
        interactionTypes = interactionTypes_text,
        directionality = directionality_text,
        attributes = attributes_text,
        pmids = pmids_text,
        sources = sources_text,
        stringsAsFactors = FALSE
      )
    }, error = function(e) {
      message(sprintf("Error in gene %s (interaction %d): %s", gene_row$name, i, e$message))
      NULL
    })
  })
  
  dfs <- Filter(Negate(is.null), dfs)
  if (length(dfs) == 0) return(NULL)
  
  do.call(rbind, dfs)
}

# ==== Query GraphQL and extract interactions for each gene
all_results <- list()
for (gene in genes) {
  cat("Processing gene:", gene, "\n")
  
  query <- sprintf('
    {
      genes(names: ["%s"]) {
        nodes {
          name
          interactions {
            drug {
              name
              conceptId
            }
            interactionScore
            interactionTypes {
              type
              directionality
            }
            interactionAttributes {
              name
              value
            }
            publications {
              pmid
            }
            sources {
              sourceDbName
            }
          }
        }
      }
    }
  ', gene)
  
  res <- POST(
    url = "https://dgidb.org/api/graphql",
    body = list(query = query),
    encode = "json",
    accept_json()
  )
  
  if (status_code(res) == 200) {
    parsed <- fromJSON(content(res, "text", encoding = "UTF-8"), flatten = TRUE)
    nodes <- parsed$data$genes$nodes
    
    if (length(nodes) > 0) {
      df <- safe_extract_interactions(nodes[1, ])
      if (!is.null(df)) {
        all_results[[gene]] <- df
      }
    } else {
      message(sprintf("No interactions found for gene: %s", gene))
    }
  } else {
    message(sprintf("Request failed for gene: %s | Status code: %d", gene, status_code(res)))
  }
}

# Combine and save the interaction data if any results were found
if (length(all_results) > 0) {
  final_df <- do.call(rbind, all_results)
  out_path <- "D:/Thesis/Proposal/Analysis/Machine Learning/DGIdb/xgboost_DGIdb_interactions_top20.csv"
  write.csv(final_df, out_path, row.names = FALSE)
  cat("Interactions saved to:\n", out_path, "\n")
  print(head(final_df))
} else {
  message("âš No drug-gene interactions found for any gene.")
}
# -------------------- DRUG INTERACTION
# Load the top 20 genes, and the interaction data for different drug treatments (Paclitaxel, Atezozolimab, and their combination)
top20_genes <- read_csv("D:/Thesis/Proposal/Analysis/Machine Learning/Results/XGBoost/xgboost_top20_gene_with_cluster_info_xgb.csv")
paclitaxel <- read_tsv("D:/Thesis/Proposal/Analysis/Machine Learning/DGIdb/Paclitaxel-interaction-Genes.tsv")
atezo_interaction <- read_tsv("D:/Thesis/Proposal/Analysis/Machine Learning/DGIdb/Atezozolimab-interaction-Genes.tsv")
atezo_pacli <- read_tsv("D:/Thesis/Proposal/Analysis/Machine Learning/DGIdb/Atezozolimab&Paclitaxel-interaction-Genes.tsv")

# Extract the names of the top 20 genes from the feature list
top20_gene_names <- top20_genes$Feature

# Combine all the drug interaction datasets, removing duplicate entries
combined_drugs <- bind_rows(paclitaxel, atezo_interaction, atezo_pacli) %>%
  distinct()

# Filter the combined dataset to only include the top 20 genes
filtered_combined <- combined_drugs %>%
  filter(gene %in% top20_gene_names)

# Save the filtered drug-gene interactions to a CSV file
write_csv(filtered_combined, "D:/Thesis/Proposal/Analysis/Machine Learning/DGIdb/xgboost_filtered_gene_drug_interactions_top20_RF.csv")
cat("File saved successfully at: filtered_gene_drug_interactions_top20_RF.csv\n")

# ============================ XGBoost_PharmGKB

# Specify the path to the PHARMGKB files
input_zip_files <- c(
  "D:/Thesis/Proposal/Analysis/Machine Learning/PHARMGKB/clinicalAnnotations.zip",
  "D:/Thesis/Proposal/Analysis/Machine Learning/PHARMGKB/clinicalAnnotations_LOE1-2.zip",
  "D:/Thesis/Proposal/Analysis/Machine Learning/PHARMGKB/pathways-tsv.zip",
  "D:/Thesis/Proposal/Analysis/Machine Learning/PHARMGKB/relationships.zip"
)

# Unzip and list the files in each zip file
for (zip_file in input_zip_files) {
  cat("ðŸ“¦ Files in:", zip_file, "\n")
  files_in_zip <- unzip(zip_file, list = TRUE)
  print(files_in_zip$Name)
  cat("\n")
}

# Load top 20 gene data and extract the unique gene names
top20_file <- "D:/Thesis/Proposal/Analysis/Machine Learning/Results/XGBoost/xgboost_top20_gene_with_cluster_info_xgb.csv"
top20_data <- fread(top20_file)
top_genes <- unique(top20_data$gene)

# Set paths for the clinical and relationships data files in the PHARMGKB zip files
zip_clinical <- "D:/Thesis/Proposal/Analysis/Machine Learning/PHARMGKB/clinicalAnnotations.zip"
zip_relationships <- "D:/Thesis/Proposal/Analysis/Machine Learning/PHARMGKB/relationships.zip"
temp_dir <- tempdir()

# Unzip and read the clinical annotations and relationships data
unzip(zip_clinical, files = "clinical_annotations.tsv", exdir = temp_dir)
clinical_data <- fread(file.path(temp_dir, "clinical_annotations.tsv"))

unzip(zip_relationships, files = "relationships.tsv", exdir = temp_dir)
relationships_data <- fread(file.path(temp_dir, "relationships.tsv"))

# Filter the clinical and relationships data based on the top 20 genes
filtered_clinical <- clinical_data[Gene %in% top_genes]
filtered_relationships <- relationships_data[
  Entity1_name %in% top_genes | Entity2_name %in% top_genes
]

# Save the filtered clinical and relationships data to CSV files
output_dir <- "D:/Thesis/Proposal/Analysis/Machine Learning/PHARMGKB"
fwrite(filtered_clinical, file.path(output_dir, "filtered_clinical_annotations_top20.csv"))
fwrite(filtered_relationships, file.path(output_dir, "filtered_relationships_top20.csv"))

cat("Filtered PHARMGKB results saved successfully for Top20 XGBoost genes.\n")

# =================================== Expression Comparison of Genes Across Different Conditions

# Define the base path for the expression matrix files
base_path <- "D:/Thesis/Proposal/Analysis/Machine Learning/Expression Matrix Gene"

# Load expression data for different conditions
file_blood_pac <- file.path(base_path, "Blood-Patient-Paclitaxel-Analysis.csv")
file_blood_combo <- file.path(base_path, "Blood-Patient-Paclitaxel-Paclitaxel plus atezolizumab-Analysis.csv")
file_tumor_pac <- file.path(base_path, "Tumor-Patient-Paclitaxel-Analysis.csv")
file_tumor_combo <- file.path(base_path, "Tumor-Patient-Paclitaxel-plus-atezolizumab-Analysis.csv")

# Load top 20 genes data
file_top20 <- "D:/Thesis/Proposal/Analysis/Machine Learning/Results/XGBoost/xgboost_top20_gene_with_cluster_info_xgb.csv"
top20 <- read_csv(file_top20)
blood_pac <- read_csv(file_blood_pac)
blood_combo <- read_csv(file_blood_combo)
tumor_pac <- read_csv(file_tumor_pac)
tumor_combo <- read_csv(file_tumor_combo)

# Convert the feature column to uppercase for consistency
top_genes <- toupper(top20$Feature)

# Define a function to extract expression data for the top genes
extract_expression <- function(df, gene_col = "gene", fc_col, group_name) {
  df[[gene_col]] <- toupper(df[[gene_col]])  # Convert gene names to uppercase
  df %>%
    filter(.data[[gene_col]] %in% top_genes) %>%
    dplyr::select(gene = all_of(gene_col), log2FC = all_of(fc_col)) %>%
    mutate(Group = group_name)
}

# Extract expression data for each condition
blood_pac_expr <- extract_expression(blood_pac, fc_col = "Post_avg_log2FC", group_name = "Blood_Paclitaxel")
blood_combo_expr <- extract_expression(blood_combo, fc_col = "Post_avg_log2FC", group_name = "Blood_Combination")
tumor_pac_expr <- extract_expression(tumor_pac, fc_col = "Pre_avg_log2FC", group_name = "Tumor_Paclitaxel")
tumor_combo_expr <- extract_expression(tumor_combo, fc_col = "Pre_avg_log2FC", group_name = "Tumor_Combination")

# Combine all expression data into one dataframe
expression_all <- bind_rows(
  blood_pac_expr, blood_combo_expr,
  tumor_pac_expr, tumor_combo_expr
)

# Plot the expression data
p <- ggplot(expression_all, aes(x = gene, y = log2FC, fill = Group)) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(
    title = "Expression of Top 20 XGBoost Genes Across Conditions",
    x = "Gene", y = "log2 Fold Change", fill = "Condition"
  ) +
  theme_minimal(base_size = 12) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

# Save the expression comparison plot
ggsave("D:/Thesis/Proposal/Analysis/Machine Learning/Expression Matrix Gene/xgboost_top20_gene_expression_conditions.png",
       plot = p, width = 10, height = 6, dpi = 300)

print(p)

# ======================================= SHAP Analysis

# Select the top 20 genes from the model
top20_genes <- head(top_features$Gene, 20)
valid_genes <- top20_genes[top20_genes %in% colnames(X_all_scaled)]

# Extract the data for the top 20 genes
X_top20_scaled <- X_all_scaled[, valid_genes, drop = FALSE]

# Create a factor for the labels with valid names
y_top20 <- factor(df$Label)
levels(y_top20) <- make.names(levels(y_top20))  # Ensure valid class names

# Check the distribution of samples across classes
print(table(y_top20))

# Train an XGBoost model with the top 20 genes
xgb_top20_model <- train(
  x = X_top20_scaled,
  y = y_top20,
  method = "xgbTree",
  trControl = trainControl(method = "cv", number = 5, classProbs = TRUE),
  tuneGrid = xgb_model$bestTune
)

# Create a Predictor object for SHAP analysis
predictor_top20 <- Predictor$new(
  model = xgb_top20_model,
  data = X_top20_scaled,
  y = y_top20,
  predict.function = function(model, newdata) {
    newdata <- as.data.frame(newdata)
    colnames(newdata) <- make.names(colnames(newdata))
    predict(model, newdata, type = "prob")[, "progressive"]  # Adjust the class name if necessary
  },
  type = "prob"
)

# Calculate SHAP values for the first sample
shap <- Shapley$new(predictor_top20, x.interest = X_top20_scaled[1, , drop = FALSE])

# Plot the SHAP values
plot(shap) +
  scale_y_discrete(labels = valid_genes) + 
  ggtitle("SHAP Contribution per Gene (Top 20)")

# Prepare SHAP data for bar plot
shap_df <- shap$results
shap_df <- shap_df[order(shap_df$phi), ]
shap_df$Gene <- factor(shap_df$feature.value, levels = shap_df$feature.value)

# Generate SHAP bar plot
shap_plot_clean <- ggplot(shap_df, aes(x = phi, y = Gene)) +
  geom_col(fill = "steelblue") +
  theme_minimal(base_size = 14) +
  labs(
    title = "SHAP Contribution per Gene (Top 20)",
    x = "SHAP Value (phi)", y = "Gene"
  )

print(shap_plot_clean)

# Save the SHAP plot
ggsave(
  filename = "D:/Thesis/Proposal/Analysis/Machine Learning/Results/XGBoost/SHAP/SHAP_plot_top20_cell1_clean.png",
  plot = shap_plot_clean,
  width = 10,
  height = 6,
  dpi = 300,
  bg = "white"
)
# ------------------------ SHAP Analysis for Multiple Cells
# Analyze SHAP values for the first 5 cells and plot the contributions of genes
cells_to_analyze <- 1:5
for (i in cells_to_analyze) {
  # Compute SHAP values for the i-th cell
  shap <- Shapley$new(predictor_top20, x.interest = X_top20_scaled[i, , drop = FALSE])
  
  # Extract SHAP values for each gene
  shap_df <- data.frame(
    Gene = colnames(X_top20_scaled),
    phi = shap$results$phi
  )
  
  # Plot the SHAP values
  p <- ggplot(shap_df, aes(x = reorder(Gene, phi), y = phi)) +
    geom_col(fill = "#2196F3") +
    coord_flip() +
    labs(
      title = sprintf("SHAP Contribution - Cell %d", i),
      x = "Gene",
      y = "SHAP Value (phi)"
    ) +
    theme_minimal(base_size = 13)
  
  # Save the SHAP plot as an image
  ggsave(sprintf("D:/Thesis/Proposal/Analysis/Machine Learning/Results/XGBoost/SHAP/xgboost_SHAP_plot_top20_cell_%d.png", i),
         plot = p, width = 10, height = 6, dpi = 300)
}

# ------------------------ SHAP Analysis for First 100 Cells
# Calculate SHAP values for the first 100 cells and compute the mean SHAP for each gene
N <- 100
shap_values_list <- lapply(1:N, function(i) {
  s <- Shapley$new(predictor_top20, x.interest = X_top20_scaled[i, , drop = FALSE])
  s$results$phi
})

# Combine the SHAP values for all 100 cells
shap_matrix <- do.call(rbind, shap_values_list)

# Compute the mean SHAP value for each gene
mean_shap <- colMeans(shap_matrix)
gene_names <- colnames(X_top20_scaled)

# Prepare a summary data frame of mean SHAP values
shap_summary <- data.frame(Gene = gene_names, MeanSHAP = mean_shap)

# Sort genes based on the absolute value of mean SHAP and select the top 10 genes
top_shap <- shap_summary[order(-abs(shap_summary$MeanSHAP)), ][1:10, ]

# Plot the top 10 genes based on their mean SHAP values
p <- ggplot(top_shap, aes(x = reorder(Gene, MeanSHAP), y = MeanSHAP, fill = MeanSHAP)) +
  geom_bar(stat = "identity", color = "black") +
  coord_flip() +
  scale_fill_gradient2(low = "#1565C0", mid = "white", high = "#D84315", midpoint = 0) +
  labs(title = "Top 10 SHAP Values Across 100 Cells",
       x = "Gene", y = "Mean SHAP Value") +
  theme_classic()

# Save the SHAP plot
ggsave("D:/Thesis/Proposal/Analysis/Machine Learning/Results/XGBoost/SHAP/SHAP_mean_top10_across_cells.png",
       plot = p, width = 10, height = 6, dpi = 300)
print(p)

# ------------------------ SHAP Analysis: Comparing Progressive vs Non-Progressive Cells
# Compute the SHAP values for progressive vs non-progressive cells and compare them
progressive_idx <- which(y_top20 == "progressive")
non_progressive_idx <- which(y_top20 == "non-progressive")

# Select the first 100 cells for each class
prog_cells <- head(progressive_idx, N)
nonprog_cells <- head(non_progressive_idx, N)

# Define a function to compute the mean SHAP values for a given set of cells
compute_shap_mean <- function(cell_indices) {
  shap_list <- lapply(cell_indices, function(i) {
    s <- Shapley$new(predictor_top20, x.interest = X_top20_scaled[i, , drop = FALSE])
    phi <- s$results$phi
    if (!is.null(phi) && is.numeric(phi) && length(phi) > 0) {
      return(as.data.frame(t(phi)))
    } else {
      message(sprintf("Skipping cell %d due to empty or invalid SHAP results.", i))
      return(NULL)
    }
  })
  shap_list <- Filter(Negate(is.null), shap_list)
  if (length(shap_list) == 0) {
    stop("No valid SHAP results to compute mean.")
  }
  shap_mat <- do.call(rbind, shap_list)
  colMeans(shap_mat)
}

# Compute mean SHAP values for progressive and non-progressive cells
mean_shap_prog <- compute_shap_mean(prog_cells)
mean_shap_nonprog <- compute_shap_mean(nonprog_cells)

# Combine the results for comparison
gene_names <- colnames(X_top20_scaled)
df_shap_compare <- data.frame(
  Gene = gene_names,
  SHAP_progressive = mean_shap_prog,
  SHAP_non_progressive = mean_shap_nonprog
)

# Calculate the absolute difference in SHAP values between the two classes
df_shap_compare$SHAP_Difference <- abs(df_shap_compare$SHAP_progressive - df_shap_compare$SHAP_non_progressive)

# Select the top 10 genes with the highest SHAP differences
top_diff <- df_shap_compare[order(-df_shap_compare$SHAP_Difference), ][1:10, ]

# Reshape the data for visualization
df_melted <- reshape2::melt(top_diff[, c("Gene", "SHAP_progressive", "SHAP_non_progressive")], id.vars = "Gene")

# Create a bar plot to visualize the comparison between progressive and non-progressive cells
p_diff <- ggplot(df_melted, aes(x = reorder(Gene, value), y = value, fill = variable)) +
  geom_bar(stat = "identity", position = "dodge") +
  coord_flip() +
  scale_fill_manual(values = c("SHAP_progressive" = "#EF5350", "SHAP_non_progressive" = "#42A5F5")) +
  labs(title = "SHAP Comparison Between Classes (Top 10 Genes)",
       x = "Gene", y = "Mean SHAP Value", fill = "Group") +
  theme_classic()

# Save the comparison plot
ggsave("D:/Thesis/Proposal/Analysis/Machine Learning/Results/XGBoost/SHAP/SHAP_class_comparison_top10.png",
       plot = p_diff, width = 10, height = 6, dpi = 300)

# Print the comparison plot
print(p_diff)

# Save the SHAP comparison results to a CSV file
write.csv(df_shap_compare,
          file = "D:/Thesis/Proposal/Analysis/Machine Learning/Results/XGBoost/SHAP/shap_comparison_progressive_vs_nonprogressive.csv",
          row.names = FALSE)

# ------------------------------------ LIMMA Analysis
# Perform differential expression analysis using LIMMA
library(limma)

# Prepare the count matrix and design matrix for LIMMA analysis
expr_matrix <- as.matrix(filtered_counts)
labels <- cell_labels$Label
labels <- factor(labels, levels = c("non_progressive", "progressive"))

# Design matrix for the linear model
design <- model.matrix(~ labels)
colnames(design) <- c("Intercept", "Progressive_vs_NonProg")

# Check the dimensions of the input data
cat("expr_matrix columns:", ncol(expr_matrix), "\n")
cat("cell_labels rows  :", nrow(cell_labels), "\n")
cat("length(labels):", length(labels), "\n")
cat("nrow(design):", nrow(design), "\n")

# Run the LIMMA analysis
png("D:/Thesis/Proposal/Analysis/Machine Learning/Results/XGBoost/LIMMA/voom_mean_variance_plot.png", width = 800, height = 600)
v <- voom(expr_matrix, design, plot = TRUE)
dev.off()

# Fit the linear model and perform empirical Bayes moderation
fit <- lmFit(v, design)
fit <- eBayes(fit)

# Extract the results for the "Progressive_vs_NonProg" contrast
results <- topTable(fit, coef = "labelsprogressive", number = Inf, adjust = "BH")

# Save all results to a CSV file
write.csv(results, "D:/Thesis/Proposal/Analysis/Machine Learning/Results/XGBoost/LIMMA/limma_DEG_results_all.csv", row.names = TRUE)

# Extract the top 20 DEGs and save them to a CSV file
topTable_results <- topTable(fit, coef = "labelsprogressive", number = 20)
write.csv(topTable_results,
          "D:/Thesis/Proposal/Analysis/Machine Learning/Results/XGBoost/LIMMA/top20_limma_DEGs.csv",
          row.names = TRUE)

# Filter significant DEGs based on adjusted p-value and logFC
all_degs <- topTable(fit, coef = "labelsprogressive", number = Inf)
write.csv(all_degs,
          "D:/Thesis/Proposal/Analysis/Machine Learning/Results/XGBoost/LIMMA/limma_DEG_results_all.csv",
          row.names = TRUE)

# Mark significant genes and save them
all_degs$Gene <- rownames(all_degs)
all_degs$Significant <- ifelse(all_degs$adj.P.Val < 0.05 & abs(all_degs$logFC) > 1, "Yes", "No")
write.csv(all_degs, file = "D:/Thesis/Proposal/Analysis/Machine Learning/Results/XGBoost/LIMMA/all_degs_results.csv", row.names = FALSE)

# Volcano plot for DEGs
ggplot(all_degs, aes(x = logFC, y = -log10(adj.P.Val), color = Significant)) +
  geom_point(alpha = 0.7) +
  scale_color_manual(values = c("No" = "gray", "Yes" = "red")) +
  theme_minimal() +
  labs(title = "Volcano Plot", x = "log2 Fold Change", y = "-log10 Adjusted P-value")

# Save the volcano plot
ggsave(
  filename = "D:/Thesis/Proposal/Analysis/Machine Learning/Results/XGBoost/LIMMA/volcano_plot_limma.png",
  width = 8, height = 6, dpi = 300
)

# ========================== Extract Results from LIMMA Analysis ============================
# Extract the results for the "progressive vs non-progressive" contrast, adjusted for multiple comparisons using the BH method.
results <- topTable(fit, coef = "labelsprogressive", number = Inf, adjust = "BH")
head(results)  # View the first few rows of the results

# Save the full results to a CSV file
write.csv(results, "D:/Thesis/Proposal/Analysis/Machine Learning/Results/XGBoost/LIMMA/limma_DEG_results_all.csv", row.names = TRUE)

# Extract the top 20 differentially expressed genes (DEGs) based on the results
topTable_results <- topTable(fit, coef = "labelsprogressive", number = 20)
head(topTable_results)  # View the top 20 results

# Save the top 20 DEGs to a CSV file
write.csv(topTable_results,
          "D:/Thesis/Proposal/Analysis/Machine Learning/Results/XGBoost/LIMMA/top20_limma_DEGs.csv",
          row.names = TRUE)

# Extract all DEGs and save to a CSV file
all_degs <- topTable(fit, coef = "labelsprogressive", number = Inf)
write.csv(all_degs,
          "D:/Thesis/Proposal/Analysis/Machine Learning/Results/XGBoost/LIMMA/limma_DEG_results_all.csv",
          row.names = TRUE)

# Add a column to mark significant genes (based on adjusted p-value and logFC threshold)
all_degs$Gene <- rownames(all_degs)
all_degs$Significant <- ifelse(all_degs$adj.P.Val < 0.05 & abs(all_degs$logFC) > 1, "Yes", "No")

# Save the results with significance marking to a CSV file
write.csv(all_degs, file = "D:/Thesis/Proposal/Analysis/Machine Learning/Results/XGBoost/LIMMA/all_degs_results.csv", row.names = FALSE)

# =============================== Volcano Plot for DEGs ================================
# Create a volcano plot to visualize DEGs, highlighting significantly upregulated or downregulated genes
ggplot(all_degs, aes(x = logFC, y = -log10(adj.P.Val), color = Significant)) +
  geom_point(alpha = 0.7) +
  scale_color_manual(values = c("No" = "gray", "Yes" = "red")) +
  theme_minimal() +
  labs(title = "Volcano Plot", x = "log2 Fold Change", y = "-log10 Adjusted P-value")

# Save the volcano plot as an image
ggsave(
  filename = "D:/Thesis/Proposal/Analysis/Machine Learning/Results/XGBoost/LIMMA/volcano_plot_limma.png",
  width = 8, height = 6, dpi = 300
)

# ============================== Filter Significant Genes ============================= 
# Filter the DEGs based on significance (adjusted p-value < 0.05) and log fold change > 1 or < -1
filtered_degs <- subset(all_degs, adj.P.Val < 0.05 & abs(logFC) > 1)

# Sort the filtered DEGs by adjusted p-value to identify the most significant genes
filtered_degs <- filtered_degs[order(filtered_degs$adj.P.Val), ]

# Select the top 20 most significant genes
top20_limma <- head(filtered_degs, 20)

# Add gene names to the dataframe for better understanding
top20_limma$Gene <- rownames(top20_limma)

# Display the top 20 significant genes
print(top20_limma)

# Reorder the top 20 genes based on their log fold change for better visualization
top20_limma$Gene <- factor(top20_limma$Gene, levels = top20_limma$Gene[order(top20_limma$logFC)])
top20_limma <- top20_limma[order(top20_limma$logFC), ]

# Save the ordered top 20 genes to a CSV file
write.csv(top20_limma,
          "D:/Thesis/Proposal/Analysis/Machine Learning/Results/XGBoost/LIMMA/top20_limma_logFC_ordered.csv",
          row.names = FALSE)

# ================================ Bar Plot for Top 20 DEGs ==========================
# Create a bar plot to show the log fold change of the top 20 DEGs, distinguishing between upregulated and downregulated genes
ggplot(top20_limma, aes(x = reorder(Gene, logFC), y = logFC, fill = logFC > 0)) +
  geom_bar(stat = "identity", width = 0.6) +
  coord_flip() +
  scale_fill_manual(
    values = c("TRUE" = "#2166AC", "FALSE" = "#B2182B"),
    labels = c("Downregulated", "Upregulated")
  ) +
  labs(
    title = "Top 20 Differentially Expressed Genes",
    x = "Gene",
    y = "log2 Fold Change",
    fill = NULL
  ) +
  theme_minimal(base_size = 15) +
  theme(
    legend.position = "top",
    axis.text.y = element_text(size = 12, face = "bold"),
    axis.text.x = element_text(size = 11),
    plot.title = element_text(size = 16, face = "bold", hjust = 0.5)
  )

# Save the bar plot as an image for publication
ggsave(
  "D:/Thesis/Proposal/Analysis/Machine Learning/Results/XGBoost/LIMMA/limma_top20_for_paper.png",
  width = 7,
  height = 5,
  dpi = 600,  # High quality for journal publication
  bg = "white"
)
